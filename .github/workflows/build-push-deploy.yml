name: Build, Push, and Deploy

on:
  push:
    branches:
      - main

jobs:
  check-app-changes:
    runs-on: ubuntu-latest
    outputs:
      app_changed: ${{ steps.filter.outputs.app_changed }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Check for app source changes
        id: filter
        run: |
          # List of app source folders/files to watch
          set +e
          CHANGED=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }} | grep -E '^(src/app/|public/|package.json|next.config.js|tsconfig.json)')
          set -e
          if [ -z "$CHANGED" ]; then
            echo "No app changes detected."
            echo "app_changed=false" >> $GITHUB_OUTPUT
          else
            echo "App changes detected."
            echo "app_changed=true" >> $GITHUB_OUTPUT
          fi

  build-and-push:
    runs-on: ubuntu-latest
    needs: check-app-changes
    if: needs.check-app-changes.outputs.app_changed == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Log in to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/cv-nextjs:latest

  deploy:
          - name: Import existing ECS service if present
            run: |
              set +e
              aws ecs describe-services --cluster cv-nextjs-cluster --services cv-nextjs-service
              if [ $? -eq 0 ]; then
                terraform import aws_ecs_service.cv_service cv-nextjs-cluster/cv-nextjs-service || true
              fi
              set -e
            working-directory: ./terraform
            env:
              AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
              AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
              AWS_REGION: us-east-1
    runs-on: ubuntu-latest
    needs: [check-app-changes, build-and-push]
    if: needs.check-app-changes.outputs.app_changed == 'false' || always()
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Cleanup orphaned network interfaces (ENIs)
        run: |
          ENIS=$(aws ec2 describe-network-interfaces --filters Name=description,Values="cv-nextjs*" --query 'NetworkInterfaces[?Status==`available`].NetworkInterfaceId' --output text)
          for eni in $ENIS; do
            echo "Deleting ENI: $eni"
            aws ec2 delete-network-interface --network-interface-id $eni || true
          done
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: us-east-1

      - name: Terraform Init
        run: terraform init
        working-directory: ./terraform

      - name: Import existing IAM role if present
        run: |
          set +e
          aws iam get-role --role-name ecsTaskExecutionRole
          if [ $? -eq 0 ]; then
            terraform import aws_iam_role.ecs_task_execution_role ecsTaskExecutionRole || true
          fi
          set -e
        working-directory: ./terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: us-east-1

      - name: Terraform Plan
        run: terraform plan
        working-directory: ./terraform

      - name: Terraform Apply
        run: terraform apply -auto-approve
        working-directory: ./terraform

      - name: Show ECS Service Public IP
        run: |
          export TASK_ARN=$(aws ecs list-tasks --cluster cv-nextjs-cluster --service-name cv-nextjs-service --query "taskArns[0]" --output text)
          export ENI_ID=$(aws ecs describe-tasks --cluster cv-nextjs-cluster --tasks $TASK_ARN --query "tasks[0].attachments[0].details[?name=='networkInterfaceId'].value" --output text)
          export PUBLIC_IP=$(aws ec2 describe-network-interfaces --network-interface-ids $ENI_ID --query "NetworkInterfaces[0].Association.PublicIp" --output text)
          echo "App Public IP: $PUBLIC_IP"
          echo "Access your app at: http://$PUBLIC_IP:3000"
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: us-east-1
